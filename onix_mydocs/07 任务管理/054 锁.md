# 锁

## 互斥锁

```c++
typedef struct lock_t
{
    struct task_t *holder; // 持有者
    mutex_t mutex;         // 互斥量
    u32 repeat;            // 重入次数
} lock_t;

void lock_init(lock_t *lock);   // 锁初始化
void lock_acquire(lock_t *lock);   // 加锁
void lock_release(lock_t *lock); // 解锁
```

## 自旋锁

自旋锁最多只能被一个可执行线程持有。如果一个执行线程试图获得一个被已经持有（即所谓的争用）的自旋锁，那么该线程就会一直进行忙循环一旋转一等待锁重新可用。要是锁未被争用，请求锁的执行线程便能立刻得到它，继续执行。在任意时间，自旋锁都可以防止多于一个的执行线程同时进入临界区。同一个锁可以用在多个位置，例如，对于给定数据的所有访问都可以得到保护和同步。

使用 CAS (Compare And Swap) 原语实现，IA32 中是 `cmpxchg` 指令，但在多处理机系统中 `cmpxchg` 指令本身不是原子的，还需要加 `lock` 来锁定内存总线实现原子操作。

## 读写锁

有时，锁的用途可以明确地分为读取和写入两个场景。并且绝大多数是读的情况，由于读并不影响数据内容，所以如果直接加锁就会影响性能，那么可以将读和写区别开来，这种形式的锁就是读写锁；

当对某个数据结构的操作可以像这样被划分为读／写 或者 消费者／生产者 两种类别时，类似读／写锁这样的机制就很有帮助了。这种自旋锁为读和写分别提供了不同的锁。一个或多个读任务可以并发地持有读者锁：相反，用于写的锁最多只能被一个写任务持有，而且此时不能有并发的读操作。有时把读／写锁叫做共享排斥锁，或者 并发／排斥锁，因为这种锁以共享（对读者而言）和排斥（对写者而言）的形式获得使用。

但在实现的时候需要注意，有可能会发生读者过多而饿死写着的情况。如果写的情况比较多就不应该使用这种锁。

## 参考文献

1. <https://wiki.osdev.org/Spinlock>
2. [[美] Robert Love / Linux内核设计与实现 / 机械工业出版社 / 2011](https://book.douban.com/subject/6097773/)
3. <https://wiki.osdev.org/Atomic_operation>
4. 这篇博客对于锁讲得很清楚，但有点深，用到的时候再看[关于同步的一点思考-上 · Issue #6 · farmerjohngit/myblog · GitHub](https://github.com/farmerjohngit/myblog/issues/6)
