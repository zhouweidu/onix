# 任务会话

## 任务会话

- 一个会话包含多个进程组
- 一个进程组包含多个进程
- 一个进程包含多个线程

会话通常与 shell 联系在一起，每一次打开 shell 产生一个会话。

组通常与管道联系在一起，多个由管道连接的进程属于一个组。

会话可以有一个控制 tty。一个会话中最多只能有一个进程组是前台进程组。Linux 中 `jobs`, `fg`, `bg`, `CTRL + Z` 可以用来控制进程。

使用 `ps j` 可以查看进程的相关属性。

## 相关系统调用

```c++
pid_t setsid(void);
```

- 如果调用进程不是进程组首领，`setsid()` 函数将创建一个新会话；
- 返回时，调用进程应该是这个新会话的会话首领，也是一个新进程组的进程组首领，并且应该没有控制终端。
- 调用进程的进程组 ID 必须与调用进程的进程 ID 相等；
- 调用进程必须是新进程组中唯一的进程，也是新会话中唯一的进程；

----

```c++
pid_t setpgrp();
```

- 如果调用进程不是会话首领，`setpgrp()` 将调用进程的进程组 ID 设置为调用进程 ID，如果 `setpgrp()` 创建了一个新会话，此新会话没有控制终端；
- 当调用进程是会话首领时，`setpgrp()` 函数不起作用；

---

```c++
int setpgid(pid_t pid, pid_t pgid);
```

- `setpgid()` 函数应该加入一个现有的进程组，或者在调用进程的会话中创建一个新的进程组；
- 会话领导者的进程组 ID 不能改变；
- 进程号与 `pid` 匹配的进程的进程组 ID 将被设置为 `pgid`；
- 特殊情况下，pid 为 0，表示调用进程应使用的进程号；
- 如果 pgid 为 0，则表示指定进程应使用的进程 ID；

---

```c++
pid_t getpgrp(void);
```

- 返回调用进程的进程组 ID

---

## 参考

- <https://www.win.tue.nl/~aeb/linux/lk/lk-10.html>
- <https://pubs.opengroup.org/onlinepubs/9699919799>
- <https://en.wikipedia.org/wiki/Process_group>
  