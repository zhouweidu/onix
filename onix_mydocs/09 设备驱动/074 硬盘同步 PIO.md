# 硬盘同步 PIO

PIO(Programmed Input/Output) 编程输入输出，PIO 模式使用了大量的 CPU 资源，因为磁盘和 CPU 之间传输的每个字节的数据都必须通过 CPU 的 IO 端口总线(而不是内存)传送。在某些 CPU 上，PIO 模式仍然可以实现每秒 16 MB 的实际传输速度，但是机器上的其他进程将得不到任何 CPU 时间片。

不过，当计算机刚开始启动时，没有其他进程。因此，在系统进入多任务模式之前，PIO 模式是一个在启动过程中使用的优秀而简单的接口。

## 硬件

ATA 磁盘规范是围绕称为 ST506 的旧规范构建的。在 ST506 中，每个磁盘驱动器通过两根电缆连接到控制板上，一根数据电缆和一根命令电缆。控制器板插入了主板总线。CPU 和控制板通过 CPU 的 IO 端口进行通信，CPU 的 IO 端口直接连接到主板总线上。

原始 IDE 规范所做的是将磁盘控制器板从主板上分离出来，并将一个控制器永久地固定在每个磁盘驱动器上。当 CPU 访问磁盘 IO 端口时，有一个芯片将 CPU 的 IO 总线引脚直接短接在 IDE 电缆上，这样 CPU 就可以直接访问驱动器的控制器板。CPU 和控制板之间的数据传输机制保持不变，现在被称为 PIO 模式。(现在，磁盘控制器芯片只是复制 IO 端口总线和 IDE 电缆之间的电信号，直到驱动器进入 PIO 以外的其他模式。)

## 主从驱动器

只有一条线专用于选择每个总线上的哪个驱动器是活动的。它要么是 高电平 或 低电平，这意味着在任何 ATA 总线上永远不会有超过两个设备运行。它们被称为主设备和从设备，没有特别的原因。它们的功能几乎完全相同。有一个特殊的 IO 端口位允许驱动程序为每个命令字节选择一个驱动器作为目标驱动器。

## 主从总线

当前的磁盘控制器芯片几乎总是支持每个芯片两个 ATA 总线。有一组标准化的 IO 端口来控制总线上的磁盘。前两个总线被称为 Primary 和 Secondary ATA 总线，并且几乎总是分别由 IO 端口 `0x1F0` ~ `0x1F7` 和 `0x170` ~ `0x177` 控制(除非您更改它)。相关的设备控制寄存器/备用状态端口分别为 IO 端口 `0x3F6` 和 `0x376`。主总线的标准 IRQ 是 IRQ14，从总线的为 IRQ15。

如果存在另外两个总线，它们通常分别由 IO 端口 0x1E8 到 0x1EF 和 0x168 到 0x16F 控制。相关的设备控制寄存器/备用状态端口为 IO 端口 0x3E6 和 0x366。

每个总线的实际控制寄存器和 IRQs 通常可以通过枚举 PCI 总线、找到所有磁盘控制器并从每个控制器的 PCI 配置空间读取信息来确定。因此，从技术上讲，在 ATA 设备检测之前，应先进行 PCI 枚举。然而，这种方法并不完全可靠。

当系统启动时，根据规格，PCI 磁盘控制器应该处于兼容模式。这意味着它应该使用标准化的 IO 端口设置。你可能别无选择，只能依靠这个事实。

## 400 纳秒延迟

ATA 规范中建议的发送 ATA 命令的方法告诉您在试图发送命令之前检查 BSY 和 DRQ 位。这意味着在发送下一个命令之前，您需要为正确的驱动器读取状态寄存器(备用状态是一个很好的选择)。这意味着您需要首先选择正确的设备，然后才能读取该状态(然后将所有其他值发送到其他 IO 端口)。这意味着驱动器选择可能总是发生在读取状态之前。这是不好的。

许多驱动器需要一点时间来响应选择命令，并将它们的状态推送到总线上。建议 **读取状态寄存器 15 次**，只关注最后一次返回的值；在选择新的主设备或从设备之后。关键是，你可以假设一个 IO 端口读至少需要 30ns，所以做前 14 个创建 420ns 延迟，这允许驱动时间将正确的电压推到总线上。

读取 IO 端口来创建延迟会浪费大量的 CPU 周期。因此，让您的驱动器记住发送到每个驱动器选择 IO 端口的最后一个值实际上是更聪明的，以避免做不必要的驱动器选择，如果值没有改变。如果您不发送驱动器选择，那么您只需要读取状态寄存器一次。

或者，无论如何，您永远都不希望向已经在为以前的命令提供服务的驱动器发送新命令。如果当前设备正在主动修改 BSY/DRQ/ERR，你的驱动程序总是需要阻塞，并且你的设备驱动程序总是知道设备在那个条件下(因为驱动程序刚刚发送命令给设备，它还没有被标记为“完成”)。一旦驱动器实际完成了一个命令，它将始终清除 BSY 和 DRQ。在下一个 驱动器选择命令之前，您可以简单地验证这一点，在命令完成时，先前选择的设备正确地清除了 BSY 和 DRQ。然后你将永远不需要检查它们是否在设备选择后清除，所以你将不需要在设备选择后读取状态寄存器。

使用 ERR/DF 位写入命令寄存器后也有类似的问题。它们是可以终止命令的两种稍微不同的错误。BSY 和 DRQ 将被清除，但 ERR 或 DF 将一直保持设置，直到您向命令寄存器写入新命令之后。如果您正在使用轮询(见下文)，您应该考虑到这样一个事实:在发送命令字节之后，您对状态寄存器的前四次读取可能仍然意外地设置了 ERR 或 DF 位。(如果你正在使用 IRQ，在 IRQ 服务时状态将总是正确的。)

## 坏扇区

出于实际目的，ATA 磁盘上有三种不同类型的坏扇区：

- 不能写入的扇区(永久性)
- 无法读取的扇区(永久性)
- 无法读取的扇区(临时)

一些磁盘制造商有一个功能，允许磁盘上的少量 “备用” 扇区重新映射到永久坏扇区。然而，该功能是非标准的，完全是制造商特有的。通常，操作系统/文件系统需要为每个驱动器的每个分区保留一个 “坏扇区列表”，并围绕坏扇区进行工作。

如上所述，也有 “临时的坏扇区”。当你读取它们时，你会得到一个硬件错误，就像一个永久坏扇区一样。但是，如果您写入该扇区，则写入将完美地工作，扇区将返回到一个良好的扇区。由于未刷新写缓存、电源峰值或电源故障，可能会发生临时坏扇区。

## 寻址模式

目前有三种寻址模式来选择对磁盘进行读写的特定扇区。它们分别是 28位LBA、48位LBA 和 CHS。CHS 模式已经过时，但将在下面快速讨论。LBA 模式中的比特数指的是扇区“地址”中的有效比特数，称为 LBA。28 位模式下，0 ~ 0x0FFFFFFF 范围内的 LBA 是合法的。这总共提供了 256M 扇区，或 128GB 可寻址空间。因此，28 位 LBA 模式对于许多当前驱动器来说也是过时的。但是，28 位 PIO 模式比 48 位寻址更快，因此对于不违反最大 LBA 值限制的驱动器或分区来说，它可能是更好的选择。

## 绝对/相对 LBA

所有使用 LBA 寻址的 ATA 命令都需要“绝对的”LBA (例如。从磁盘最开始的扇区偏移——完全忽略分区边界)。乍一看，在操作系统中以同样的格式存储 LBA 值似乎是最有效的。然而，事实并非如此。始终有必要验证传递到驱动程序的 lba，因为它们确实属于正在访问的分区。在代码中使用相对于分区的 LBA 寻址是最聪明的做法，因为这样就不需要测试被访问的 LBA 是否位于当前分区的 “前端”。所以你只需要做一半的测试。这弥补了需要将当前分区开始的绝对 LBA 添加到传递给驱动程序的每个 “相对” LBA 值的事实。同时，这样做可以让您访问一个额外的 LBA 地址位。

## 寄存器

一个 ATA 总线通常有十个 I/O 端口来控制它的行为。对于主总线，这些I/O端口通常是0x1F0(“I/O”端口基地址) 到 0x1F7 和 0x3F6(“控制”端口基地址) 到 0x3F7。对于辅助总线，它们通常是 0x170 到 0x177 和 0x376 到 0x377。一些系统可能有非标准的 ATA 总线端口位置，在这种情况下，它可能是有帮助的咨询 PCI 部分，以确定如何检索端口地址为系统中的各种设备。

这些表中的值是相对于所谓的端口基数的;距离 I/O 端口基1的端口偏移实际上指的是端口 0x1F1 (0x1F0 + 1 = 0x1F1)。这样做是因为基本端口可能会根据任何给定系统中的硬件而变化。另外，这些 I/O 端口中的一些根据它们是被读还是被写映射到不同的寄存器。

### 硬盘控制端口

| Primary 通道 | Secondary 通道 | in 操作      | out 操作     |
| ------------ | -------------- | ------------ | ------------ |
| 0x1F0        | 0x170          | Data         | Data         |
| 0x1F1        | 0x171          | Error        | Features     |
| 0x1F2        | 0x172          | Sector count | Sector count |
| 0x1F3        | 0x173          | LBA low      | LBA low      |
| 0x1F4        | 0x174          | LBA mid      | LBA mid      |
| 0x1F5        | 0x175          | LBA high     | LBA high     |
| 0x1F6        | 0x176          | Device       | Device       |
| 0x1F7        | 0x177          | Status       | Command      |

- 0x1F0：16bit 端口，用于读写数据
- 0x1F1：检测前一个指令的错误
- 0x1F2：读写扇区的数量
- 0x1F3：起始扇区的 0 ~ 7 位
- 0x1F4：起始扇区的 8 ~ 15 位
- 0x1F5：起始扇区的 16 ~ 23 位
- 0x1F6:
    - 0 ~ 3：起始扇区的 24 ~ 27 位
    - 4: 0 主盘, 1 从盘
    - 6: 0 CHS, 1 LBA
    - 5 ~ 7：固定为1
- 0x1F7: out
    - 0xEC: 识别硬盘
    - 0x20: 读硬盘
    - 0x30: 写硬盘
- 0x1F7: in / 8bit
    - 0 ERR
    - 3 DRQ 数据准备完毕
    - 7 BSY 硬盘繁忙

### 错误寄存器

| 位  | 缩写  | 描述                      |
| --- | ----- | ------------------------- |
| 0   | AMNF  | Address mark not found.   |
| 1   | TKZNF | Track zero not found.     |
| 2   | ABRT  | Aborted command.          |
| 3   | MCR   | Media change request.     |
| 4   | IDNF  | ID not found.             |
| 5   | MC    | Media changed.            |
| 6   | UNC   | Uncorrectable data error. |
| 7   | BBK   | Bad Block detected.       |

### 状态寄存器

| 位  | 缩写 | 描述                                             |
| --- | ---- | ------------------------------------------------ |
| 0   | ERR  | 标志错误发生                                     |
| 1   | IDX  | 索引，总为 0                                     |
| 2   | CORR | 纠正数据，总为 0                                 |
| 3   | DRQ  | PIO 数据准备完毕                                 |
| 4   | SRV  | 重叠模式服务请求                                 |
| 5   | DF   | 驱动器故障错误                                   |
| 6   | RDY  | 当驱动器停机或发生错误后，位是清除的。否则置位。 |
| 7   | BSY  | 硬盘繁忙                                         |

从技术上讲，当设置了 BSY 时，状态字节中的其他位都是无意义的。测试 “Seek Complete”(DSC) 位通常也是一个坏主意，因为它已被弃用，并被较新的 SRV 位取代。

### 备用状态寄存器

读取设备控制寄存器端口会得到备用状态寄存器的值。Alternate Status 的值总是与 Regular Status 端口(在 Primary 总线上是 0x1F7)相同，但是读取Alternate Status 端口不影响中断。

### 设备控制寄存器

还有一个额外的 IO 端口改变每个 ATA 总线的行为，称为设备控制寄存器(在主总线上，端口 0x3F6)。每个 ATA 总线都有自己的控制寄存器。


| 位    | 缩写 | 描述                                                               |
| ----- | ---- | ------------------------------------------------------------------ |
| 0     | -    | 总为 0                                                             |
| 1     | nIEN | 将此设置为停止当前设备发送中断                                     |
| 2     | SRST | 设置，然后清除(5us 后)，这对总线上的所有 ATA 驱动器做一个 “软重置” |
| 3 ~ 6 | -    | 保留                                                               |
| 7     | HOB  | 设置为回读发送到 IO 端口的最后一个 LBA48 值的高阶字节              |

所有其他的位都是保留的，并且应该总是清除的。一般来说，您会希望清除 HOB、SRST 和 nIEN，在启动期间，将每个设备控制寄存器设置为 0。

### 驱动器地址寄存器

| 位    | 缩写      | 描述                                     |
| ----- | --------- | ---------------------------------------- |
| 0     | DS0       | 选择驱动器 1，选择驱动器 0 时清除        |
| 1     | DS1       | 选择驱动器 1，选择驱动器 1 时清除        |
| 2 ~ 5 | HS0 - HS3 | 合起来代表当前选定的磁头                 |
| 6     | WTG       | 写门，在写驱动器的过程中降低             |
| 7     | n/a       | 保留与软驱控制器的兼容性，可能使用这个位 |

## 复位驱动器/软件复位

对于非 ATAPI 驱动器，驱动器在发生重大错误后复位驱动器的唯一方法是在总线上做“软件复位”。

在适当的控制寄存器中为总线设置位 2 (SRST，值= 4)。这将重置总线上的两个 ATA 设备，然后，你得自己再清除一遍。总线上的主驱动器被自动选择

ATAPI 驱动器在它们的 LBA_LOW 和 LBA_HIGH IO 端口上设置值，但不应该重置或甚至终止它们的当前命令。

## 28 位 PIO

假设您有一个扇区计数字节和一个 28 位 LBA 值。扇区数为 0 表示 256 个扇区=128K。

注意:当发送一个命令字节时，状态寄存器的 RDY 位是清除的，在 DRQ 设置之前，您可能需要等待(技术上最多 30 秒)驱动器旋转起来。如果是轮询，在读取 Status 的前四次，可能还需要忽略 ERR 和 DF。

一个在主总线上读取 28 位 LBA PIO 模式的示例:

1. 发送“主”的 0xE0 或“从”的 0xF0，或 LBA 的最高 4 位到端口 0x1F6
2. 发送 NULL 字节到 0x1F1 端口，如果你喜欢(它被忽略和浪费大量的 CPU 时间):
3. 发送扇区数量到端口 0x1F2
4. 发送 LBA 的低 8 位到端口 0x1F3
5. 将 LBA 的下一个 8 位发送到端口 0x1F4
6. 发送 LBA 的下一个 8 位到端口 0x1F5
7. 将 READ SECTORS 命令 (0x20) 发送到端口0x1F7
8. 等待 IRQ 或轮询
9. 从 I/O 端口 0x1F0 传输 256 个 16 位值，每次一个 uint16_t。(在汇编中，REP INSW 更加高效)
10. 然后循环返回，等待每个连续扇区的下一个 IRQ (或再次轮询，参见下一条说明)
11. 轮询 PIO 驱动器注意: 将 PIO 数据块的最后一个 uint16_t 转移到数据 IO 端口后，给驱动器一个 400ns 的延迟来重置其 DRQ 位(并可能再次设置 BSY，同时清空/填充驱动器的缓冲区)

注意发送到端口 0x1f6 的 “魔法位”:位 6(值= 0x40)是 LBA 位。这必须为 LBA28 或 LBA48 传输设置。CHS 传输时必须清除。

位 7 和 5 对于当前的 ATA 驱动器是过时的，但必须设置为向后兼容非常老的(ATA1)驱动器。

### 写 28 位 LBA

如果使用 28 位 PIO 模式写扇区，需要向命令端口发送 write sectors (0x30) 命令。

请勿使用REP OUTSW传输数据，每个 OUTSW 输出 uint16_t 之间必须有微小的延迟，一个 jmp $+2 大小的延迟

确保在每个写命令完成后进行 Cache Flush (ATA 命令 0xE7)

## 48 位 PIO

使用 48 位 PIO 读取扇区与 28 位方法非常相似

注意:扇区计数为0 意味着 65536 扇区=32MB。尽量不要连续两次向同一个 IO 端口发送字节。这样做要比对不同的 IO 端口执行两个 outb() 命令慢得多。

重要的是扇区计数、特性和 LBA 字节 4、5 和 6 的高字节在低字节之前进入各自的端口

假设你有一个扇区计数 uint16_t 和一个 6 字节的 LBA 值。脑海中从低到高为 LBA 字节编号为 1 到 6。将 2 字节扇区计数发送到端口 0x1F2(高字节优先)，并以适当的顺序将 6 个 LBA 字节对发送到端口 0x1F3 到 0x1F5


一个例子:

- 发送 0x40 为“主” 端口或 0x50 为“从”端口 0x1F6: outb(0x1F6, 0x40 | (slavebit << 4))

- outb (0x1F2, sectorcount高字节)

- outb (0 x1f3 LBA4)

- outb (0 x1f4 LBA5)

- outb (0 x1f5 LBA6)

- outb (0x1F2, sectorcount 低字节)

- outb (0 x1f3 LBA1)

- outb (0 x1f4 LBA2)

- outb (0 x1f5 LBA3)

发送“READ SECTORS EXT” 命令 (0x24) 到端口0x1F7 : outb(0x1F7, 0x24)

注意发送到端口 0x1f6 的“魔法位”:位 6(值= 0x40)是 LBA 位。对于 LBA48 命令，任何支持 LBA48 的驱动器将忽略该端口上的所有其他位。如果这将使您的代码更干净，您可以设置它们(使用与 LBA28 相同的魔法位)。

如果要在 48 位 PIO 模式下写扇区，则发送命令 “write sectors EXT”(0x34)。(和以前一样，在编写时不要使用 REP OUTSW) 记住在每个写命令完成后进行缓存刷新

命令字节发送后，以与 28 位 PIO 读写命令完全相同的方式传输每个扇区的数据

## CHS 模式

柱面 (Cylinder)，磁头(Head)，扇区(Sector) 模式已经完全过时了，但由于遗留原因，有一些关于它的事情需要了解。

最古老的驱动器有许多玻璃“盘片”，每个盘片有两个读/写“磁头”。头总是垂直排成一行。其中一个盘子的一个头通常用于“计时”。当所有的盘面旋转时，每个盘头勾画出一个圆圈，所有的盘头一起勾画出一个“圆柱体”。每个头划出的圆圈又细分为若干个“扇区”。每个扇区可用于存储 512 字节的数据。选择圆柱、磁头和扇区成为一种寻址模式。

更换柱面意味着移动整个头部总成，这是要避免的，如果可能的话

但重要的是，这些信息在过去 20 年里都不是真的——除了计算机一直通过人工 CHS 寻址访问数据

在 CHS 模式中，每个驱动器都有一个“几何形状”，CHS值的合法范围。典型的最大合法值是 Cyl = 0 ~ 1023, Head = 0 ~ 15, Sector = 1 ~ 63。

请注意，扇区= 0 总是非法的，这是导致错误的常见原因。(也有可能一些硬件/驱动器将接受高达 65537 的 Cylinder 值)

将 CHS 地址转换为 LBA 是很简单的:(Cylinder * TotalHeads + SelectedHead) * SectorsPerTrack + (SectorNum - 1)。有时程序会要求一个 CHS 地址，你需要手工进行计算。

在 CHS 模式下访问扇区基本上与进行 28 位 LBA 读写相同，除了在写入 bit Flag s端口时保持 LBA 位(值= 0x40)关闭，并且向IO 端口发送各种 CHS 字节而不是 LBA 字节。

## 参考文献

- <https://wiki.osdev.org/PCI_IDE_Controller>
- Information Technology - AT Attachment - 8 ATA/ATAPI Command Set (ATA8-ACS)
- <http://www.bswd.com/pciide.pdf>
- <http://bswd.com/idems100.pdf>
- <https://wiki.osdev.org/ATA_PIO_Mode>
