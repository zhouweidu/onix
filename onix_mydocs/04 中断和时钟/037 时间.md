# 时间

## CMOS 信息

PC 机的 CMOS (Complementary metal oxide semiconductor 互补金属氧化物半导体) 内存，实际上是由电池供电的 64 或 128 字节 RAM 内存块，是系统时钟芯片的一部分。有些机器还有更大的内存容量。由 IBM 于 1984 年引入 PC 机，当时使用的芯片是摩托罗拉 MC146818A。

该 64 字节的 CMOS 原先在 IBM PC-XT 机器上用于保存时钟和日期信息，存放的格式是 BCD 码。由于这些信息仅用去 14 字节，剩余的字节就用来存放一些系统配置数据了。这里有独立的电池为其供电。

CMOS 的地址空间是在基本地址空间之外的。因此其中不包括可执行的代码。它需要使用在端口 `0x70`,`0x71` 使用 `in` 和 `out` 指令来访问。

为了读取指定偏移位置的字节，首先需要使用 `out` 向端口 `0x70` 发送指定字节的偏移值，然后使用 `in` 指令从 `0x71` 端口读取指定的字节信息。不过在选择字节（寄存器）时最好屏蔽到 NMI 中断。向 `0x70` 端口写入的 8 位的最高位 `0x80`。

下面是 CMOS 内存信息的一张简表。

| 地址偏移值  | 内容说明                    |
| ----------- | --------------------------- |
| 0x00        | 当前秒值 (实时钟)           |
| 0x01        | 闹钟秒值                    |
| 0x02        | 当前分钟 (实时钟)           |
| 0x03        | 闹钟分钟值                  |
| 0x04        | 当前小时值 (实时钟)         |
| 0x05        | 闹钟小时值                  |
| 0x06        | 一周中的当前天 (实时钟)     |
| 0x07        | 一月中的当日日期 (实时钟)   |
| 0x08        | 当前月份 (实时钟)           |
| 0x09        | 当前年份 (实时钟)           |
| 0x0a        | RTC 状态寄存器 A            |
| 0x0b        | RTC 状态寄存器 B            |
| 0x0c        | RTC 状态寄存器 C            |
| 0x0d        | RTC 状态寄存器 D            |
| 0x0e        | POST 诊断状态字节           |
| 0x0f        | 停机状态字节                |
| 0x10        | 磁盘驱动器类型              |
| 0x11        | 保留                        |
| 0x12        | 硬盘驱动器类型              |
| 0x13        | 保留                        |
| 0x14        | 设备字节                    |
| 0x15        | 基本内存 (低字节)           |
| 0x16        | 基本内存 (高字节)           |
| 0x17        | 扩展内存 (低字节)           |
| 0x18        | 扩展内存 (高字节)           |
| 0x19 ~ 0x2d | 保留                        |
| 0x2e        | 校验和 (低字节)             |
| 0x2f        | 校验和 (高字节)             |
| 0x30        | 1Mb 以上的扩展内存 (低字节) |
| 0x31        | 1Mb 以上的扩展内存 (高字节) |
| 0x32        | 当前所处世纪值              |
| 0x33        | 信息标志                    |

## 关键词

- NMI 不可屏蔽中断

## 一些问题

- 散装芯片？

CMOS 芯片集成了很多功能，有些甚至和时间无关，其中保存了 BIOS 启动时需要的一些信息，所以 CMOS 寄存器的值尽量不要修改，仅作只读之用，除非你非常明白自己在做什么，否则你需要更新 CMOS **校验和**。另外 CMOS 芯片还集成了 NMI 的开关。总之，在那个勤俭节约的年代，芯片只要有空间就要充分利用。节约成本，不过这确实留下了很多兼容性的包袱，鱼和熊掌，不可兼得。**先让程序跑起来吧，剩下的以后再说**。

- 世纪寄存器？

最开始的 CMOS 中没有世纪寄存器，在接近 2000 年的时候，硬件厂商开始意识到这可能是个问题，所以添加了世纪寄存器 (`0x32`)，但是这并没有一个固定的标准，导致不同的硬件厂商使用了不同的寄存器。

- 日历？

公元历法，1582 年，时任罗马教皇格里高利十三世予以批准执行，替代了原先的儒略历(Julian Calender)，故又称为格里高利历(Gregorian calendar)。

其中每四年一个闰年，每四百年减去三个闰年。

这里主要的原因是每个太阳年的时间大约是 365.2422 天；

但是，如果每年以 365 天计算的话，那么四年就要少 0.2422 * 4 = 0.9688 天，于是每隔四年会加一个闰年，这样每四年多计算了 0.0312 天；

但是，如果每四年都加天的话，那么四百年之后又多了 0.0312 * 100 = 3.12 天，于是在前面的每 100 年，又去掉一个闰年；

这样 400 年的误差被控制在了 0.12 天；这 0.12 天的误差要起效果，需要等待至少 3200 年，所以可能就忽略了吧。

## 参考引用

- 赵炯 - 《Linux 内核完全注释》
- <https://wiki.osdev.org/CMOS>
- <https://en.wikipedia.org/wiki/Calendar>
- <https://en.wikipedia.org/wiki/Gregorian_calendar>
