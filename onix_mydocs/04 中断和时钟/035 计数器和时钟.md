# 计数器和时钟

## 目录

- bug: 显卡驱动滚屏
- bug: interrupt 0x20
- 计数器：
- 时钟
- 时间片：两个时钟中断之间的时间间隔

----

常用的可编程定时计数器 (Programmable Interval Timer PIT) 有 Intel 8253/8254，其中 8254 可以称为 8253 的增强版。

在 8253 内部有 3 个独立的计数器，分别是计数器 0 ~ 2，端口号分别为 0x40 ~ 0x42；每个计数器完全相同，都是 16 位大小，相互独立，互不干涉。

8253 计数器是个减法计数器，从初值寄存器中得到初值，然后载入计数器中，然后随着时钟变化递减。计数器初值寄存器，计数器执行寄存器，和输出锁存器都是 16 位的寄存器，高八位和低八位可以单独访问。

## 计数器

三个计数器有自己各自的用途：

- 计数器 0，端口号 0x40，用于产生时钟信号，它采用工作方式 3；
- 计数器 1，端口号 0x41，用于 DRAM 的定时刷新控制；
- 计数器 2，端口号 0x42，用于内部扬声器发出不同音调的声音，原理是给扬声器输送某频率的方波；


计数器 0 用于产生时钟中断，就是连接在 IRQ0 引脚上的时钟，也就是控制计数器 0 可以控制时钟发生的频率，以改变时间片的间隔；

## 8253 控制字

控制字寄存器，端口号 0x43，是 8 位寄存器，控制字寄存器也成为模式控制寄存器，用于指定计数器的 工作方式、读写格式 及 数制。

控制字结构：

| 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- |
| SC1 | SC0 | RL1 | RL0 | M2  | M1  | M0  | BCD |


- SC(Select Counter) 0 ~ 1：计数器选择位
    - 00 计数器 0
    - 01 计数器 1
    - 10 计数器 2
    - 11 无效
- RL(Read Load) 0 ~ 1：读写操作位
    - 00 锁存数据，供 CPU 读
    - 01 只读写低字节
    - 10 只读写高字节
    - 11 先读写低字节，后读写高字节
- M (Mode) 0 ~ 2：模式选择
    - 000：模式 0
    - 001：模式 1
    - x10：模式 2
    - x11：模式 3
    - 100：模式 4
    - 101：模式 5
- BCD：(Binary Coded Decimal) 码
    - 0 表示二进制计数器
    - 1 二进制编码的十进制计数器

## 模式

- 模式 0：计数结束时中断
- 模式 1：硬件可重触发单稳方式
- 模式 2：比率发生器，用于分频
- 模式 3：方波发生器
- 模式 4：软件触发选通
- 模式 5：硬件触发选通

模式时序图

![](./images/intel_8253_mode.jpg)

## 振荡器

振荡器的频率大概是 1193182 Hz，假设希望中断发生的频率为 100Hz，那么计数器初值寄存器的值为：

$$V = {1193182 \over 100} = 11931$$

## 其他的问题

- 为什么 振荡器 的频率是 1193182 Hz？

最初的 PC 机，使用一个基础振荡器来生成频率，14.31818 MHz，因为这个频率常用于电视线路，这个基础频率除以 3 就得到了频率 4.77272666 MHz 用于 CPU；除以 4 得到频率 3.579545 MHz 用于 CGA 显卡控制器。从逻辑上将前两个频率求最大公约数，就得到了频率 1.1931816666 MHz，这个方案极大的节约了成本，因为 14.31818 MHz 的振荡器可以大量的生产，所以就更便宜。

## 参考文献

1. <https://www.cpcwiki.eu/imgs/e/e3/8253.pdf>
2. <https://wiki.osdev.org/Programmable_Interval_Timer>
2. 郑刚 - 《操作系统真象还原》
